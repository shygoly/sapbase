import { Injectable } from '@nestjs/common'
import { WorkflowDefinition, WorkflowState, WorkflowTransition, WorkflowStatus } from './workflow-definition.entity'
import { WorkflowDefinitionService } from './workflow-definition.service'

/**
 * Service to convert AI module step3_stateFlow definitions to WorkflowDefinitions
 */
@Injectable()
export class WorkflowConverterService {
  constructor(private workflowDefinitionService: WorkflowDefinitionService) {}

  /**
   * Convert step3_stateFlow JSON to WorkflowDefinition
   */
  convertStateFlowToWorkflow(
    stateFlow: Record<string, any>,
    entityType: string,
    moduleName: string,
  ): {
    name: string
    description: string
    entityType: string
    states: WorkflowState[]
    transitions: WorkflowTransition[]
  } {
    // Extract states from stateFlow
    const states: WorkflowState[] = []
    const transitions: WorkflowTransition[] = []

    // Handle different stateFlow formats
    if (stateFlow.states && Array.isArray(stateFlow.states)) {
      // Format: { states: [{ name, initial, final, ... }] }
      for (const state of stateFlow.states) {
        states.push({
          name: state.name || state.id,
          initial: state.initial === true,
          final: state.final === true,
          metadata: state.metadata || {},
        })
      }
    } else if (stateFlow.stateMachine) {
      // Format: { stateMachine: { states: {...}, transitions: {...} } }
      const sm = stateFlow.stateMachine
      if (sm.states) {
        for (const [stateName, stateDef] of Object.entries(sm.states)) {
          const state = stateDef as any
          states.push({
            name: stateName,
            initial: state.initial === true,
            final: state.final === true,
            metadata: state.metadata || {},
          })
        }
      }
    } else {
      // Try to infer from transitions
      const inferredStates = new Set<string>()
      if (stateFlow.transitions && Array.isArray(stateFlow.transitions)) {
        for (const trans of stateFlow.transitions) {
          if (trans.from) inferredStates.add(trans.from)
          if (trans.to) inferredStates.add(trans.to)
        }
      }

      // Create states from inferred names
      for (const stateName of inferredStates) {
        states.push({
          name: stateName,
          initial: states.length === 0, // First state is initial
          final: false,
          metadata: {},
        })
      }
    }

    // Extract transitions
    if (stateFlow.transitions && Array.isArray(stateFlow.transitions)) {
      for (const trans of stateFlow.transitions) {
        transitions.push({
          from: trans.from || trans.source,
          to: trans.to || trans.target,
          guard: trans.guard || trans.condition,
          action: trans.action || trans.hook,
          metadata: trans.metadata || {},
        })
      }
    } else if (stateFlow.stateMachine?.transitions) {
      const smTransitions = stateFlow.stateMachine.transitions
      for (const [key, trans] of Object.entries(smTransitions)) {
        const t = trans as any
        transitions.push({
          from: t.from || key.split('->')[0],
          to: t.to || key.split('->')[1],
          guard: t.guard || t.condition,
          action: t.action || t.hook,
          metadata: t.metadata || {},
        })
      }
    }

    // Ensure at least one initial state
    if (states.length > 0 && !states.some((s) => s.initial)) {
      states[0].initial = true
    }

    return {
      name: `${moduleName} Workflow`,
      description: `Workflow for ${entityType} entities, auto-generated from module definition`,
      entityType,
      states,
      transitions,
    }
  }

  /**
   * Create WorkflowDefinition from step3_stateFlow
   */
  async createWorkflowFromStateFlow(
    stateFlow: Record<string, any>,
    entityType: string,
    moduleName: string,
    organizationId: string,
  ): Promise<WorkflowDefinition> {
    const workflowData = this.convertStateFlowToWorkflow(stateFlow, entityType, moduleName)

    return this.workflowDefinitionService.create(
      {
        ...workflowData,
        metadata: {
          source: 'ai-module',
          autoGenerated: true,
        },
      },
      organizationId,
    )
  }

  /**
   * Update WorkflowDefinition from step3_stateFlow
   */
  async updateWorkflowFromStateFlow(
    workflowId: string,
    stateFlow: Record<string, any>,
    entityType: string,
    moduleName: string,
    organizationId: string,
  ): Promise<WorkflowDefinition> {
    const workflowData = this.convertStateFlowToWorkflow(stateFlow, entityType, moduleName)

    return this.workflowDefinitionService.update(
      workflowId,
      {
        ...workflowData,
        status: WorkflowStatus.ACTIVE,
        metadata: {
          source: 'ai-module',
          autoGenerated: true,
        },
      },
      organizationId,
    )
  }
}
